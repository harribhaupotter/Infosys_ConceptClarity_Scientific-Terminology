from fastapi import FastAPI, HTTPException, Depends, Query
from app.database import users_collection, feedback_collection
from app.schemas import SignupRequest, LoginRequest, ExplainRequest, FeedbackRequest, SaveRequest
from app.auth import hash_password, verify_password, create_token
from app.dependencies import get_current_user, admin_only
from fastapi.middleware.cors import CORSMiddleware
import requests
from datetime import datetime
from collections import defaultdict
from collections import defaultdict
import os
#this is for the colab
# LLM_URL = "https://unattacked-rayden-wheezingly.ngrok-free.dev/generate"
LLM_URL = os.environ.get("LLM_URL", "http://127.0.0.1:8001/generate")
app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.post("/auth/signup")
def signup(data: SignupRequest):
    if users_collection.find_one({"email": data.email}):
        raise HTTPException(status_code=400, detail="User already exists")

    users_collection.insert_one({
        "name": data.name,
        "email": data.email,
        "password": hash_password(data.password),
        "role": "user"
    })

    return {"message": "User created successfully"}

@app.post("/auth/login")
def login(data: LoginRequest):
    user = users_collection.find_one({"email": data.email})
    if not user or not verify_password(data.password, user["password"]):
        raise HTTPException(status_code=401, detail="Invalid credentials")

    token = create_token({
        "email": user["email"],
        "name": user["name"],
        #"role": user["role"].
        "role": user.get("role", "user")
    })

    return {"access_token": token}

@app.get("/user/profile")
def profile(user=Depends(get_current_user)):
    return {
        "name": user["name"],
        "email": user["email"]
    }


@app.post("/explain")
def explain(data: ExplainRequest, user=Depends(get_current_user)):
    response = requests.post(
        LLM_URL,
        headers={"Content-Type": "application/json"},
        json={"term": data.term,
              "level": data.level,
              "language": data.language
              },
        timeout=120
    )
    response.raise_for_status()

    result = response.json()

    # Get relative terms from LLM response (already generated by LLM)
    relative_terms = result.get("relative_terms", [])
    
    # Fallback to empty list if not present
    if not relative_terms or not isinstance(relative_terms, list):
        relative_terms = []

    # Store search history as an array of objects with term and explanation.
    # Keep only the latest 5 entries using $slice: -5.
    users_collection.update_one(
        {"email": user["email"]},
        {
            "$push": {
                "search_history": {
                    "$each": [
                        {
                            "term": data.term,
                            "level": data.level,
                            "explanation": result.get("explanation", ""),
                            "relative_terms": relative_terms
                        }
                    ],
                    "$slice": -5,
                }
            }
        },
    )

    # Ensure relative_terms is in the response (should already be there from LLM)
    if "relative_terms" not in result:
        result["relative_terms"] = relative_terms

    return result


@app.get("/user/search-history")
def get_history(user=Depends(get_current_user)):
    db_user = users_collection.find_one({"email": user["email"]})
    raw_history = db_user.get("search_history", [])

    # Preserve existing API response format: return a list of search terms (strings).
    # Handle both legacy string entries and new { "term": ..., "explanation": ... } objects.
    terms = []
    for item in raw_history:
        if isinstance(item, dict):
            term = item.get("term")
            if term:
                terms.append(term)
        else:
            terms.append(str(item))

    return terms

@app.post("/explain/guest")
def explain_guest(data: ExplainRequest):
    response = requests.post(
        LLM_URL,
        headers={"Content-Type": "application/json"},
        json={"term": data.term,
              "level": data.level,
              "language": data.language
              },
        timeout=120
    )
    response.raise_for_status()
    result = response.json()
    
    # Get relative terms from LLM response (already generated by LLM)
    relative_terms = result.get("relative_terms", [])
    
    # Fallback to empty list if not present
    if not relative_terms or not isinstance(relative_terms, list):
        relative_terms = []
    
    # Ensure relative_terms is in the response (should already be there from LLM)
    if "relative_terms" not in result:
        result["relative_terms"] = relative_terms
    
    return result

@app.get("/admin/users")
def get_all_users(admin=Depends(admin_only)):
    users = list(users_collection.find({}, {"password": 0}))
    
    # Fetch all feedback and group by user_email
    all_feedback = list(feedback_collection.find({}))
    feedback_by_email = defaultdict(list)
    for feedback in all_feedback:
        user_email = feedback.get("user_email", "unknown")
        if user_email != "guest":  # Skip guest feedback
            feedback_by_email[user_email].append(feedback)
    
    # Convert ObjectId to string and add feedback to users
    for user in users:
        if "_id" in user:
            user["_id"] = str(user["_id"])
        
        # Add feedback for this user
        user_email = user.get("email", "")
        user["feedback"] = list(feedback_by_email.get(user_email, []))
        
        # Convert feedback ObjectIds to strings
        for feedback_item in user["feedback"]:
            if "_id" in feedback_item:
                feedback_item["_id"] = str(feedback_item["_id"])
            # Convert datetime to string if present
            if "created_at" in feedback_item:
                feedback_item["created_at"] = feedback_item["created_at"].isoformat() if hasattr(feedback_item["created_at"], "isoformat") else str(feedback_item["created_at"])
        
        # Map saved_explanations to saved_items for frontend compatibility
        saved_explanations = user.get("saved_explanations", [])
        if saved_explanations:
            # Convert datetime objects to ISO format strings
            for item in saved_explanations:
                if "saved_at" in item and hasattr(item["saved_at"], "isoformat"):
                    item["saved_at"] = item["saved_at"].isoformat()
            user["saved_items"] = saved_explanations
        else:
            user["saved_items"] = []
        
        # Remove saved_items for admin users (but keep feedback so admin can view it)
        if user.get("role") == "admin":
            user.pop("saved_items", None)
            user.pop("saved_explanations", None)
    
    return users

@app.get("/admin/feedback")
def get_all_feedback(admin=Depends(admin_only)):
    """
    Get all feedback including guest feedback.
    Admin only endpoint.
    """
    all_feedback = list(feedback_collection.find({}).sort("created_at", -1))
    
    # Convert ObjectId to string and datetime to ISO format
    for feedback_item in all_feedback:
        if "_id" in feedback_item:
            feedback_item["_id"] = str(feedback_item["_id"])
        # Convert datetime to string if present
        if "created_at" in feedback_item:
            feedback_item["created_at"] = feedback_item["created_at"].isoformat() if hasattr(feedback_item["created_at"], "isoformat") else str(feedback_item["created_at"])
    
    return all_feedback

@app.post("/feedback")
def submit_feedback(data: FeedbackRequest, user: dict = Depends(get_current_user)):
    """
    Submit feedback for an explanation.
    Requires authentication.
    """
    feedback_doc = {
        "term": data.term,
        "rating": data.rating,
        "reason": data.reason,
        "explanation": data.explanation,
        "user_email": user.get("email", "unknown"),
        "user_name": user.get("name", "unknown"),
        "created_at": datetime.utcnow()
    }
    
    feedback_collection.insert_one(feedback_doc)
    
    return {"message": "Feedback submitted successfully"}

@app.post("/feedback/guest")
def submit_feedback_guest(data: FeedbackRequest):
    """
    Submit feedback for an explanation (guest users).
    """
    feedback_doc = {
        "term": data.term,
        "rating": data.rating,
        "reason": data.reason,
        "explanation": data.explanation,
        "user_email": "guest",
        "user_name": "guest",
        "created_at": datetime.utcnow()
    }
    
    feedback_collection.insert_one(feedback_doc)
    
    return {"message": "Feedback submitted successfully"}

@app.post("/save")
def save_explanation(data: SaveRequest, user=Depends(get_current_user)):
    """
    Save a term and its explanation for the current user.
    Requires authentication.
    """
    db_user = users_collection.find_one({"email": user["email"]})
    saved_items = db_user.get("saved_explanations", [])
    
    # Check if this term+explanation combination already exists
    # We'll use term as the unique identifier (user can save same term only once)
    existing_item = next(
        (item for item in saved_items if item.get("term") == data.term),
        None
    )
    
    if existing_item:
        # Update existing saved item
        users_collection.update_one(
            {"email": user["email"], "saved_explanations.term": data.term},
            {
                "$set": {
                    "saved_explanations.$.explanation": data.explanation,
                    "saved_explanations.$.saved_at": datetime.utcnow()
                }
            }
        )
        return {"message": "Explanation updated successfully", "saved": True}
    else:
        # Add new saved item
        saved_item = {
            "term": data.term,
            "explanation": data.explanation,
            "saved_at": datetime.utcnow()
        }
        users_collection.update_one(
            {"email": user["email"]},
            {
                "$push": {
                    "saved_explanations": saved_item
                }
            }
        )
        return {"message": "Explanation saved successfully", "saved": True}

@app.get("/user/saved-explanations")
def get_saved_explanations(user=Depends(get_current_user)):
    """
    Get all saved explanations for the current user.
    Requires authentication.
    """
    db_user = users_collection.find_one({"email": user["email"]})
    saved_items = db_user.get("saved_explanations", [])
    
    # Convert datetime objects to ISO format strings
    for item in saved_items:
        if "saved_at" in item and hasattr(item["saved_at"], "isoformat"):
            item["saved_at"] = item["saved_at"].isoformat()
    
    # Return in reverse chronological order (newest first)
    saved_items.reverse()
    
    return saved_items

@app.delete("/save")
def delete_saved_explanation(term: str = Query(...), user=Depends(get_current_user)):
    """
    Delete a saved explanation by term for the current user.
    Requires authentication.
    """
    result = users_collection.update_one(
        {"email": user["email"]},
        {
            "$pull": {
                "saved_explanations": {"term": term}
            }
        }
    )
    
    if result.modified_count == 0:
        raise HTTPException(status_code=404, detail="Saved explanation not found")
    
    return {"message": "Saved explanation deleted successfully"}
